<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Binance ForceOrder Combined Test</title>
  <style>
    body { font-family: sans-serif; padding: 1rem; }
    #log { white-space: pre-wrap; background: #f5f5f5; padding: 1rem; border-radius: 4px; }
  </style>
</head>
<body>
  <h1>Binance Combinedâ€¯ForceOrder.js Test (ETHUSDT)</h1>
  <p>Console â†’ WS frames; box updates every 10â€¯s:</p>
  <div id="log">Waiting for dataâ€¦</div>

  <script>
    console.log('ðŸŸ¢ HTML loaded');
  </script>

  <script type="module">
    // Inâ€‘page buffer
    const events = [];
    window._liqEvents = events;

    // Combined stream for all forced liquidations, publishes each second
    const WS_URL = 'wss://fstream.binance.com/stream?streams=!forceOrder@arr';
    console.log('ðŸŸ¢ Connecting to', WS_URL);
    const ws = new WebSocket(WS_URL);

    ws.onopen = () => console.log('ðŸŸ¢ WebSocket open');
    ws.onerror = (e) => console.error('âŒ WS error:', e);

    ws.onmessage = ({ data }) => {
      // Every second youâ€™ll get a JSON like:
      // { stream: "!forceOrder@arr", data: [ {...}, {...} ] }
      console.log('ðŸ“¥ raw frame:', data);
      let msg;
      try { msg = JSON.parse(data); }
      catch (e) { return console.error('Malformed JSON', e, data); }

      if (!Array.isArray(msg.data)) return;
      // Filter only for ETHUSDT entries
      for (const entry of msg.data) {
        // entry has shape {E, o:{s,S,q,p,origQty,...}}
        if (entry.o.s !== 'ETHUSDT') continue;
        const ts    = entry.E;
        const side  = entry.o.S;               // "BUY" or "SELL"
        const size  = Number(entry.o.origQty); // origQty = actual qty liquidated
        const price = Number(entry.o.p);
        const usd   = size * price;
        events.push({ ts, side, size, price, usd });
      }

      // Prune >24â€¯h old
      const cutoff = Date.now() - 24*60*60*1000;
      while (events.length && events[0].ts < cutoff) events.shift();
    };

    // Aggregator for UI
    function aggregate(fromMs, toMs) {
      let total = 0, buys = 0, sells = 0, count = 0;
      for (const e of events) {
        if (e.ts >= fromMs && e.ts < toMs) {
          total += e.usd;
          e.side === 'BUY' ? buys  += e.usd
                           : sells += e.usd;
          count++;
        }
      }
      return { total, buys, sells, count };
    }

    // UI refresh every 10â€¯s
    setInterval(() => {
      const now = Date.now(), ago = now - 60*1000;
      const { total, buys, sells, count } = aggregate(ago, now);
      document.getElementById('log').textContent =
        `Last 1â€¯min:\n` +
        ` â€¢ Events: ${count}\n` +
        ` â€¢ Total USD: $${total.toLocaleString()}\n` +
        ` â€¢ Buys liquiÂ­dated: $${buys.toLocaleString()}\n` +
        ` â€¢ Sells liquiÂ­dated: $${sells.toLocaleString()}`;
    }, 10_000);
  </script>
</body>
</html>
